Linar Khakim, [28.11.2024 0:36]
#include <stdint.h>

// Кадры для состояния "покой" (IDLE)
static const uint8_t FRAME_IDLE[] = {
    // Данные массива для состояния покоя (вы можете взять их из оригинального luna.c)
};

// Кадры для состояния "ходьба" (WALK)
static const uint8_t FRAME_WALK_1[] = {
    // Данные массива для первого шага ходьбы
};

static const uint8_t FRAME_WALK_2[] = {
    // Данные массива для второго шага ходьбы
};

// Кадры для состояния "бег" (RUN)
static const uint8_t FRAME_RUN_1[] = {
    // Данные массива для первого кадра бега
};

static const uint8_t FRAME_RUN_2[] = {
    // Данные массива для второго кадра бега
};

// Кадры для состояния "Caps Lock включён" (CAPS_LOCK)
static const uint8_t FRAME_CAPS_LOCK[] = {
    // Данные массива для отображения Caps Lock
};

// Общий массив кадров для анимации
static const uint8_t *ANIMATION_FRAMES[] = {
    FRAME_IDLE,
    FRAME_WALK_1,
    FRAME_WALK_2,
    FRAME_RUN_1,
    FRAME_RUN_2,
    FRAME_CAPS_LOCK
};

#define TOTAL_FRAMES (sizeof(ANIMATION_FRAMES) / sizeof(ANIMATION_FRAMES[0]))

// Функция для рендеринга текущего кадра
void render_frame(const uint8_t *frame, size_t frame_size, const struct device *display_dev) {
    if (device_is_ready(display_dev)) {
        display_write(display_dev, 0, 0, frame, frame_size);
    }
}

Linar Khakim, [28.11.2024 0:40]
uint16_t anim_timer = 0;
uint16_t anim_sleep = 0;

/* current frame */
uint8_t current_frame = 0;

/* status variables */
int current_wpm_read = 0;

#        ifndef SNEAK_DISABLE
bool isSneaking = false;
#        endif
bool isJumping  = false;
bool showedJump = true;
bool isBarking  = false;

/* logic */
static void render_luna(int LUNA_X, int LUNA_Y) {
    // clang-format off
    /* Sit */
    static const char PROGMEM sit[2][ANIM_SIZE] = {
      /* 'sit1', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1c,
        0x02, 0x05, 0x02, 0x24, 0x04, 0x04, 0x02, 0xa9, 0x1e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x08, 0x68, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x82, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x0c, 0x10, 0x10, 0x20, 0x20, 0x20, 0x28,
        0x3e, 0x1c, 0x20, 0x20, 0x3e, 0x0f, 0x11, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'sit2', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1c,
        0x02, 0x05, 0x02, 0x24, 0x04, 0x04, 0x02, 0xa9, 0x1e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x90, 0x08, 0x18, 0x60, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x82, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x0c, 0x10, 0x10, 0x20, 0x20, 0x20, 0x28,
        0x3e, 0x1c, 0x20, 0x20, 0x3e, 0x0f, 0x11, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }
    };

    /* Walk */
    static const char PROGMEM walk[2][ANIM_SIZE] = {
      /* 'walk1', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x90, 0x90, 0x90, 0xa0, 0xc0, 0x80, 0x80,
        0x80, 0x70, 0x08, 0x14, 0x08, 0x90, 0x10, 0x10, 0x08, 0xa4, 0x78, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0xfc, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0xea, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1c, 0x20, 0x20, 0x3c, 0x0f, 0x11, 0x1f, 0x03,
        0x06, 0x18, 0x20, 0x20, 0x3c, 0x0c, 0x12, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'walk2', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,
        0x00, 0xe0, 0x10, 0x28, 0x10, 0x20, 0x20, 0x20, 0x10, 0x48, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x20, 0xf8, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x30, 0xd5, 0x20, 0x1f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x20, 0x30, 0x0c, 0x02, 0x05, 0x09, 0x12, 0x1e,
        0x02, 0x1c, 0x14, 0x08, 0x10, 0x20, 0x2c, 0x32, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }
    };

    /* Run */
    static const char PROGMEM run[2][ANIM_SIZE] = {
      /* 'run1', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x08, 0x08, 0xc8, 0xb0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x40, 0x40, 0x3c, 0x14, 0x04, 0x08, 0x90, 0x18, 0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0xc4, 0xa4, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc8, 0x58, 0x28, 0x2a, 0x10, 0x0f, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x09, 0x04, 0x04, 0x04, 0x04, 0x02, 0x03, 0x02, 0x01, 0x01,
        0x02, 0x02, 0x04, 0x08, 0x10, 0x26, 0x2b, 0x32, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

Linar Khakim, [28.11.2024 0:40]
/* 'run2', 32x22px */
      {
        0x00, 0x00, 0x00, 0xe0, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
        0x80, 0x80, 0x78, 0x28, 0x08, 0x10, 0x20, 0x30, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0xb0, 0x50, 0x55, 0x20, 0x1f, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x28, 0x37,
        0x02, 0x1e, 0x20, 0x20, 0x18, 0x0c, 0x14, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }
    };

    /* Bark */
    static const char PROGMEM bark[2][ANIM_SIZE] = {
      /* 'bark1', 32x22px */
      {
        0x00, 0xc0, 0x20, 0x10, 0xd0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40,
        0x3c, 0x14, 0x04, 0x08, 0x90, 0x18, 0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xc8, 0x48, 0x28, 0x2a, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x28, 0x37, 0x02, 0x02,
        0x04, 0x08, 0x10, 0x26, 0x2b, 0x32, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'bark2', 32x22px */
      {
        0x00, 0xe0, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40,
        0x40, 0x2c, 0x14, 0x04, 0x08, 0x90, 0x18, 0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x48, 0x28, 0x2a, 0x10, 0x0f, 0x20, 0x4a, 0x09, 0x10,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x28, 0x37, 0x02, 0x02,
        0x04, 0x08, 0x10, 0x26, 0x2b, 0x32, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }
    };

    #ifndef SNEAK_DISABLE
    /* Sneak */
    static const char PROGMEM sneak[2][ANIM_SIZE] = {
      /* 'sneak1', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xc0, 0x40, 0x40, 0x80, 0x00, 0x80, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x1e, 0x21, 0xf0, 0x04, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x04,
        0x04, 0x04, 0x03, 0x01, 0x00, 0x00, 0x09, 0x01, 0x80, 0x80, 0xab, 0x04, 0xf8, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1c, 0x20, 0x20, 0x3c, 0x0f, 0x11, 0x1f, 0x02, 0x06,
        0x18, 0x20, 0x20, 0x38, 0x08, 0x10, 0x18, 0x04, 0x04, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'sneak2', 32x22px */
      {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xe0, 0xa0, 0x20, 0x40, 0x80, 0xc0, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3e, 0x41, 0xf0, 0x04, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x04,
        0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x40, 0x40, 0x55, 0x82, 0x7c, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x20, 0x30, 0x0c, 0x02, 0x05, 0x09, 0x12, 0x1e, 0x04,
        0x18, 0x10, 0x08, 0x10, 0x20, 0x28, 0x34, 0x06, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      }
    };
    #endif
    // clang-format on

Linar Khakim, [28.11.2024 0:40]
/* animation */
    void animate_luna(void) {
        /* jump */
        if (isJumping  !showedJump) {
            /* clear */
            oled_set_cursor(LUNA_X, LUNA_Y + 2);
            oled_write_ln("", false);

            oled_set_cursor(LUNA_X, LUNA_Y - 1);

            showedJump = true;
        } else {
            /* clear */
            oled_set_cursor(LUNA_X, LUNA_Y - 1);
            oled_write_ln("", false);

            oled_set_cursor(LUNA_X, LUNA_Y);
        }

        /* switch frame */
        current_frame = (current_frame + 1) % 2;

        /* current status */
        if (isBarking) {
            oled_write_raw_P(bark[abs(1 - current_frame)], ANIM_SIZE);
#        ifndef SNEAK_DISABLE
        } else if (isSneaking) {
            oled_write_raw_P(sneak[abs(1 - current_frame)], ANIM_SIZE);
#        endif
        } else if (current_wpm_read <= MIN_WALK_SPEED) {
            oled_write_raw_P(sit[abs(1 - current_frame)], ANIM_SIZE);

        } else if (current_wpm_read <= MIN_RUN_SPEED) {
            oled_write_raw_P(walk[abs(1 - current_frame)], ANIM_SIZE);

        } else {
            oled_write_raw_P(run[abs(1 - current_frame)], ANIM_SIZE);
        }
    }

    /* animation timer */
    if (timer_elapsed(anim_timer) > ANIM_FRAME_DURATION) {
        anim_timer = timer_read();
        animate_luna();
    }
}

/* KEYBOARD PET END */
#    endif

#    ifdef RAW_ENABLE
#        include "transactions.h"
char time[6] = "     ";
#    endif

static void print_layout_and_wpm(void) {
#    ifdef RAW_ENABLE
    oled_set_cursor(0, 0);
    oled_write(time, false);
#    endif

    oled_set_cursor(0, 2);
    switch (get_highest_layer(default_layer_state)) {
        case _QWERTY:
            oled_write_P(PSTR("Qwrty"), false);
            break;
        case _COLEMAK:
            oled_write_P(PSTR("Colmk"), false);
            break;
        case _PROGRAMMER_DVORAK:
            oled_write_P(PSTR("P Dvk"), false);
            break;
        case _GAMING:
            oled_write_P(PSTR("Game "), false);
            break;
        default:
            oled_write_P(PSTR("Undef"), false);
    }

    /* wpm counter */
    oled_set_cursor(0, 9);
    oled_write_P(PSTR("WPM:\n"), false);
    oled_write(get_u8_str(get_current_wpm(), ' '), false);
}

bool shift_held = false;
bool ctrl_held  = false;

static void print_status_narrow(void) {
    if (keymap_config.swap_lctl_lgui) {
        oled_write_ln_P(PSTR("MAC"), false);
    } else {
        oled_write_ln_P(PSTR(""), false);
        // oled_write_ln_P(PSTR("WIN"), false);
    }

    /* Print current layer */
    oled_set_cursor(0, 2);
    oled_write("LAYER", false);

    oled_set_cursor(0, 3);
    switch (get_highest_layer(layer_state)) {
        case _COLEMAK:
        case _QWERTY:
        case _PROGRAMMER_DVORAK:
        case _GAMING:
            oled_write_P(PSTR("Base "), false);
            break;
        case _RAISE:
            oled_write_P(PSTR("Raise"), false);
            break;
        case _LOWER:
            oled_write_P(PSTR("Lower"), false);
            break;
        case _ADJUST:
            oled_write_P(PSTR("Adj  "), false);
            break;
        default:
            oled_write_P(PSTR("Undef"), false);
    }

    /* lock status */
    led_t led_usb_state = host_keyboard_led_state();
    oled_set_cursor(0, 5);
    if (led_usb_state.caps_lock) {
        oled_write("CAPS", true);
#    if defined(CAPS_WORD_ENABLE)
    } else if (is_caps_word_on()) {
        oled_write("WORD", true);
#    endif
    } else {
        oled_write("\n", true);
    }
    oled_set_cursor(0, 6);
    oled_write(shift_held ? "SHIFT" : "\n", true);
    oled_set_cursor(0, 7);
    oled_write(ctrl_held ? "CTRL" : "\n", true);
    // oled_write_ln("Num", !led_usb_state.num_lock);
    // oled_write_ln("Scrl", led_usb_state.scroll_lock);

#    ifndef PET_DISABLE
    /* KEYBOARD PET RENDER START */
    render_luna(0, 11);
    /* KEYBOARD PET RENDER END */
#    endif
}

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    return OLED_ROTATION_270;
}

bool oled_task_user(void) {
#    ifndef

Linar Khakim, [28.11.2024 0:40]
PET_DISABLE
    /* KEYBOARD PET VARIABLES START */
    current_wpm_read = get_current_wpm();
    /* KEYBOARD PET VARIABLES END */
#    endif

    if (is_keyboard_master()) { // Drashna's OLED timeout off code for animations
        if (timer_elapsed32(oled_timer) > 30000) {
            oled_off();
            return false;
        } else {
            oled_on();
        }
    } else {
        if (is_oled_on()) {
            oled_on();
        } else {
            oled_off();
        }
    }

    if (is_keyboard_master()) {
        print_status_narrow();
    } else {
        print_layout_and_wpm();
    }
    return false;
}

#    ifdef RAW_ENABLE
uint16_t last_time_update = 0;

void raw_hid_receive(uint8_t *data, uint8_t length) {
    // Set the time on the main-side keyboard
    strcpy(time, (char *)data);
    last_time_update = timer_read();
    dprintf("Received '%s' via hid\n", time);
}

void sync_time(uint8_t in_buflen, const void *in_data, uint8_t out_buflen, void *out_data) {
    // Set the time on the slave-side keyboard
    strcpy(time, (char *)in_data);
}

void increment_time(void) {
    if (time[4] == '9') {
        if (time[3] == '5') {
            if (time[1] == '9') {
                // Increment ten hour
                time[0] = time[0] + 1;
                time[1] = '0';
                time[3] = '0';
                time[4] = '0';
            } else if (time[1] == '3' && time[0] == '2') {
                // Increment day
                strcpy(time, "00:00");
            } else {
                // Increment hour
                time[1] = time[1] + 1;
                time[3] = '0';
                time[4] = '0';
            }
        } else {
            // Increment ten minute
            time[3] = time[3] + 1;
            time[4] = '0';
        }
    } else {
        // Increment minute
        time[4] = time[4] + 1;
    }
}

void housekeeping_task_user(void) {
    if (is_keyboard_master()) {
        // Interact with slave every 1000ms
        static uint16_t last_sync = 0;
#        ifdef CONSOLE_ENABLE
#        endif
        if (timer_elapsed(last_sync) > 1000) {
            if (transaction_rpc_send(TIME_SYNC, 6, time)) {
                dprintf("Sent '%s' to the right keyboard\n", time);
                last_sync = timer_read();
            } else {
                dprintln("Sending to right keyboard failed!");
            }
        }
        if (timer_elapsed(last_time_update) >= 60000) {
            last_time_update = timer_read() - (timer_elapsed(last_time_update) - 60000);
            if (time[2] == ':') {
                increment_time();
            }
        }
    }
}
#    endif

#    if defined(RAW_ENABLE)  defined(CONSOLE_ENABLE)
void keyboard_post_init_user(void) {
#        ifdef CONSOLE_ENABLE
    debug_enable = true;
    // debug_matrix = true;
    // debug_keyboard = true;
    // debug_mouse = true;
#        endif
#        ifdef RAW_ENABLE
    transaction_register_rpc(TIME_SYNC, sync_time);
    dprintf("Registered sync_time method for syncing time between split\n", time);
#        endif
}
#    endif

#endif
